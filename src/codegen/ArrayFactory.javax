/*
 * This file is part of TiPi (a Toolkit for Inverse Problems and Imaging)
 * developed by the MitiV project.
 *
 * Copyright (c) 2014 the MiTiV project, http://mitiv.univ-lyon1.fr/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

//# include <common.javax>       // Get common definitions.
//# def className = ArrayFactory // Define the name of the class.
package ${package};
import mitiv.base.Shape;
import mitiv.base.Shaped;
import mitiv.base.Traits;


/**
 * Conversion functions.
 *
 * @author Éric Thiébaut & Jonathan Léger.
 */
public abstract class ${className} implements Shaped {
    /**
     * This class is not instantiable.
     */
    protected ${className}() {}

    //# for dst in ${BYTE} : ${DOUBLE}
    //#     def dst_type = ${}{type_${dst}}
    //#     def dst_Type = ${}{Type_${dst}}
    //#     def dst_TYPE = ${}{TYPE_${dst}}
    //#     if ${dst} == 2
    //#         def a = an
    //#         def A = An
    //#     else
    //#         def a = a
    //#         def A = A
    //#     end
    /**
     * Convert a ShapedArray into ${a} ${dst_Type}Array.
     * <p>
     * The operation is lazy, in the sense that {@code src} is returned if it
     * is already of the requested type.
     *
     * @param src - The source array.
     * @return ${A} ${dst_Type}Array whose values has been converted into ${dst_type}'s
     *         from those of {@code src}.
     */
    public ${dst_Type}Array to${dst_Type}(ShapedArray src) {
        int srcType = src.getType();
        if (src.getType() == Traits.${dst_TYPE}) {
            return (${dst_Type}Array)src;
        }
        int number = src.getNumber();
        ${dst_type}[] out = new ${dst_type}[number];
        switch (srcType) {
            //# for src in ${BYTE} : ${DOUBLE}
            //#     if ${src} != ${dst}
            //#         def src_type = ${}{type_${src}}
            //#         def src_Type = ${}{Type_${src}}
            //#         def src_TYPE = ${}{TYPE_${src}}
        case Traits.${src_TYPE}:
            {
                ${src_type}[] inp = ((${src_Type}Array)src).flatten(false);
                for (int j = 0; j < number; ++j) {
                    out[j] = (${dst_type})inp[j];
                }
            }
            break;
            //#     end
            //# end // loop over SRC type
        default:
            throw new IllegalArgumentException("unexpected type (BUG)");
        }
        return wrap(out, src.getShape());
    }

    //# end // loop over DST type

    //# for id in ${BYTE} : ${DOUBLE}
    //#     def type = ${}{type_${id}}
    //#     def Type = ${}{Type_${id}}
    //#     def TYPE = ${}{TYPE_${id}}
    //#     def TypeArray = ${Type}Array
    //#     if ${id} == 2
    //#         def a = an
    //#         def A = An
    //#     else
    //#         def a = a
    //#         def A = A
    //#     end
    //#     for rank in 1 : 9
    //#         def argDimList = dim1
    //#         def declDimList = int dim1
    //#         def k = 1
    //#         while ${k} < ${rank}
    //#             eval k += 1
    //#             def argDimList = ${argDimList}, dim${k}
    //#             def declDimList = ${declDimList}, int dim${k}
    //#         end
    /**
     * Wrap an array of ${type} values into ${a} ${Type}Array.
     * <p>
     * Notes: (i) The source array {@code arr} and the returned ${Type}Array
     * share the same contents. (ii) The storage order is assumed to be
     * {@link Shaped#COLUMN_MAJOR}. (iii) The result can be safely casted into a
     * {@link #${Type}1D}, {@link #${Type}2D}, ... according to the number of
     * dimensions in {@code shape}.
     *
     * @param arr  - The source array.
     //#         def k = 0
     //#         while ${k} < ${rank}
     //#             eval k += 1
     //#             def kth = ${}{nth_${k}}
     * @param dim${k} - The ${kth} dimension of the ${rank}D array.
     //#         end
     * @return A ${Type}Array wrapped around the source array {@code arr}.
      */
    public static ${Type}${rank}D wrap(${type}[] arr, ${declDimList}) {
        return ${Type}${rank}D.wrap(arr, ${argDimList});
    }

    //#     end // loop over rank
    /**
     * Wrap ${a} ${TypeArray} object around a simple array of ${type}'s.
     * <p>
     * Note that the storage order is assumed to be {@link Shaped#COLUMN_MAJOR}
     * and that the result can be safely casted into a {@link #${Type}1D},
     * {@link #${Type}2D}, ... according to the number of dimensions in
     * {@code shape}.
     *
     * @param arr  - The input array.
     * @param dims - The dimension list of the result.
     *
     * @return An instance of ${TypeArray} sharing its data with the input array
     *         {@code arr}.
     * @see {@link #flatten(boolean)}, {@link Shaped#COLUMN_MAJOR}.
     */
    public static ${TypeArray} wrap(${type}[] arr, int[] dims) {
        return wrap(arr, Shape.make(dims));
    }

    /**
     * Wrap ${a} ${TypeArray} object around a simple array of ${type}'s.
     * <p>
     * Note that the storage order is assumed to be {@link Shaped#COLUMN_MAJOR}
     * and that the result can be safely casted into a {@link #${Type}1D},
     * {@link #${Type}2D}, ... according to the number of dimensions in
     * {@code shape}.
     *
     * @param data   - The input array.
     * @param shape  - The shape of the result.
     * @param cloneShape - Indicate whether the {@code shape} parameter must be
     *                     cloned.
     *
     * @return An instance of ${TypeArray} sharing its data with the input array
     *         {@code data}.
     * @see {@link #flatten(boolean)}, {@link Shaped#COLUMN_MAJOR}.
     */
    public static ${Type}Array wrap(${type}[] data, Shape shape) {
        switch (shape.rank()) {
        //# for rank in 1:9
        case ${rank}:
            return ${Type}${rank}D.wrap(data, shape);
        //# end
        default:
            throw new IllegalArgumentException("Invalid shape.");
        }
    }

    //# end // loop over types
}

/*
 * Local Variables:
 * mode: Java
 * tab-width: 8
 * indent-tabs-mode: nil
 * c-basic-offset: 4
 * fill-column: 78
 * coding: utf-8
 * ispell-local-dictionary: "american"
 * End:
 */
